# Документація: Алгоритми керування кешем

## Огляд проекту

Цей проект реалізує та порівнює різні алгоритми кешування для оптимізації обчислень:

1. **LRU Cache** - для оптимізації доступу до масивів даних
2. **Splay Tree** - для кешування чисел Фібоначчі
3. **Порівняльний аналіз** продуктивності двох підходів

## Структура проекту

```
goit-algo2-hw-07/
├── README.md                 # Основна документація
├── DOCUMENTATION.md          # Детальна документація (цей файл)
├── requirements.txt          # Залежності проекту
├── main.py                   # Головний скрипт для запуску обох завдань
├── 
├── lru_cache.py             # Реалізація LRU Cache
├── splay_tree.py            # Реалізація Splay Tree
├── 
├── task1.py                 # Завдання 1: LRU Cache оптимізація
├── task2.py                 # Завдання 2: Порівняння Fibonacci
├── 
├── test_task1.py            # Тести для завдання 1
├── test_task2.py            # Тести для завдання 2
└── fibonacci_comparison.png # Графік результатів
```

## Детальний опис реалізації

### 1. LRU Cache (lru_cache.py)

**Призначення**: Least Recently Used cache для швидкого доступу до даних

**Ключові характеристики**:
- **Структура**: Поєднання hash map та doubly linked list
- **Складність**: O(1) для всіх операцій (get, put)
- **Ємність**: Фіксована (1000 елементів для завдання)

**Основні методи**:
```python
get(key)      # Отримати значення (переміщує до голови)
put(key, val) # Зберегти значення (видаляє найменш використаний при переповненні)
remove(key)   # Видалити ключ
clear()       # Очистити кеш
```

**Алгоритм роботи**:
1. При доступі до елемента - переміщення до голови списку
2. При додаванні нового - додати до голови
3. При переповненні - видалити з хвоста (LRU)

### 2. Splay Tree (splay_tree.py)

**Призначення**: Самобалансуюче бінарне дерево пошуку з операцією splay

**Ключові характеристики**:
- **Структура**: Бінарне дерево з операціями ротації
- **Складність**: Амортизована O(log n) для пошуку/вставки
- **Особливість**: Автоматично переміщує часто використовувані елементи до кореня

**Основні операції**:
```python
search(key)           # Пошук з splay операцією
insert(key, value)    # Вставка з балансуванням
_splay(root, key)     # Операція splay
_left_rotate(x)       # Ліва ротація
_right_rotate(x)      # Права ротація
```

**Типи ротацій**:
1. **Zig-Zig**: Два повороти в одному напрямку
2. **Zig-Zag**: Повороти в різних напрямках
3. **Zig**: Один поворот (елемент - син кореня)

### 3. Завдання 1: Оптимізація доступу до даних

**Мета**: Порівняти продуктивність операцій з масивом з кешем та без

**Типи операцій**:
- `Range(L, R)`: Обчислення суми елементів array[L:R+1]
- `Update(index, value)`: Оновлення array[index] = value

**Параметри тестування**:
- Розмір масиву: 100,000 елементів
- Кількість запитів: 50,000
- "Гарячі" діапазони: 30 популярних відрізків
- Ймовірність "гарячого" запиту: 95%
- Частка Update операцій: 3%

**Функції**:
```python
range_sum_no_cache(array, left, right)              # Без кешу
range_sum_with_cache(array, left, right, cache)     # З кешем
update_no_cache(array, index, value)                # Без кешу
update_with_cache(array, index, value, cache)       # З інвалідацією
```

**Інвалідація кешу**: При оновленні елемента видаляються всі діапазони, що містять цей індекс.

### 4. Завдання 2: Порівняння обчислення Фібоначчі

**Мета**: Порівняти ефективність LRU Cache та Splay Tree для кешування рекурсивних обчислень

**Тестові значення**: 0, 50, 100, 150, ..., 950 (крок 50)

**Функції**:
```python
@lru_cache(maxsize=None)
def fibonacci_lru(n):           # З декоратором LRU
    
def fibonacci_splay(n, tree):   # З Splay Tree
```

**Вимірювання**: Середній час виконання з 3 запусків для кожного значення n

## Результати експериментів

### Завдання 1: LRU Cache оптимізація

**Типовий результат**:
```
Без кешу :  16.75 c
LRU-кеш  :  6.22 c  (прискорення ×2.7)
Ефективність кешування: 62.8%
```

**Пояснення результатів**:
- Значне прискорення (2-3x) завдяки повторним запитам до "гарячих" діапазонів
- Ефективність залежить від частоти повторень та розміру кешу
- Інвалідація при Update операціях частково знижує ефективність

### Завдання 2: Порівняння Fibonacci

**Типовий результат**:
```
LRU Cache в середньому швидший у 3.03 разів
LRU Cache виграє: 20/20 тестів
```

**Пояснення результатів**:
- **LRU Cache (@lru_cache)** завжди швидший
- Вбудована оптимізація Python для рекурсивних функцій
- Splay Tree має додаткові накладні витрати на ротації
- Обидва методи набагато краще наївної рекурсії O(2^n)

## Висновки

### Коли використовувати LRU Cache:
- Для кешування результатів обчислень
- Коли є чіткі "гарячі" та "холодні" дані
- Для оптимізації повторних запитів
- У високонавантажених системах

### Коли використовувати Splay Tree:
- Для адаптивних структур даних
- Коли паттерн доступу змінюється
- Для самооптимізуючих кешів
- У системах з нерівномірним розподілом запитів

### Загальні рекомендації:
1. **Для Python**: Використовуйте `@lru_cache` для функцій
2. **Для складних структур**: Розгляньте спеціалізовані кеші
3. **Для адаптивності**: Splay Tree або подібні структури
4. **Для простоти**: Стандартні рішення (dict + LRU логіка)

## Технічні деталі

### Встановлення та запуск:
```bash
pip install -r requirements.txt
python main.py              # Запуск обох завдань
python task1.py             # Тільки завдання 1
python task2.py             # Тільки завдання 2
python test_task1.py        # Тести для завдання 1
python test_task2.py        # Тести для завдання 2
```

### Залежності:
- `matplotlib>=3.5.0` - для побудови графіків
- `numpy>=1.21.0` - для числових обчислень
- Стандартні модулі: `timeit`, `functools`, `random`, `time`

### Налаштування:
- Розмір кешу LRU: 1000 (можна змінити в task1.py)
- Кількість тестових запитів: 50,000 
- Максимальне число Фібоначчі: 950
- Кількість вимірювань для усереднення: 3

## Оптимізації

### Можливі покращення LRU Cache:
1. **TTL (Time To Live)** - автоматичне видалення застарілих записів
2. **Weighted LRU** - врахування "ваги" різних елементів
3. **Multi-level cache** - кілька рівнів кешування

### Можливі покращення Splay Tree:
1. **Bulk operations** - оптимізація для пакетних операцій
2. **Persistent structure** - збереження попередніх версій
3. **Concurrent access** - підтримка багатопоточності

### Альтернативні підходи:
1. **Redis** - зовнішній кеш-сервер
2. **LFU Cache** - Least Frequently Used
3. **ARC Cache** - Adaptive Replacement Cache
4. **2Q Algorithm** - покращена версія LRU
