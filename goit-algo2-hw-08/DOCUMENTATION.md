# Документація: Алгоритми контролю потоку та обмеження швидкості

## Огляд проекту

Цей проект реалізує два ключові алгоритми обмеження швидкості (rate limiting) для чат-системи:

1. **Sliding Window Rate Limiter** - точний контроль кількості запитів у часовому вікні
2. **Throttling Rate Limiter** - фіксований інтервал між повідомленнями

## Структура проекту

```
goit-algo2-hw-08/
├── README.md                 # Основна документація
├── DOCUMENTATION.md          # Детальна документація (цей файл)
├── requirements.txt          # Залежності (стандартна бібліотека Python)
├── main.py                   # Головний скрипт з демонстрацією
├── 
├── task1.py                  # Sliding Window Rate Limiter
├── task2.py                  # Throttling Rate Limiter
├── 
├── test_task1.py             # Тести для завдання 1
└── test_task2.py             # Тести для завдання 2
```

## Детальний опис алгоритмів

### 1. Sliding Window Rate Limiter

**Принцип роботи**: Відстежує кількість запитів у "ковзному" часовому вікні.

**Ключові характеристики**:
- **Структура даних**: `Dict[str, deque]` - для кожного користувача зберігає чергу часових міток
- **Параметри**: `window_size` (розмір вікна), `max_requests` (максимум запитів у вікні)
- **Складність**: O(1) амортизована для операцій, O(k) для очищення, де k - кількість застарілих записів

**Основні методи**:
```python
_cleanup_window(user_id, current_time)    # Очищення застарілих запитів
can_send_message(user_id)                 # Перевірка можливості відправки
record_message(user_id)                   # Запис повідомлення
time_until_next_allowed(user_id)          # Розрахунок часу очікування
```

**Алгоритм роботи**:
1. При кожному запиті очищуються застарілі записи (старші за `window_size`)
2. Перевіряється кількість активних запитів у вікні
3. Якщо `len(active_requests) < max_requests` - дозволяється новий запит
4. Інакше розраховується час очікування до видалення найстаршого запиту

**Переваги**:
- Точний контроль кількості запитів
- Дозволяє "пакетні" запити до досягнення ліміту
- Справедливий розподіл ресурсів
- Автоматичне очищення пам'яті

**Недоліки**:
- Більше використання пам'яті (O(n) де n - кількість запитів у вікні)
- Складніша реалізація
- Потребує періодичного очищення

### 2. Throttling Rate Limiter

**Принцип роботи**: Забезпечує мінімальний інтервал між послідовними запитами.

**Ключові характеристики**:
- **Структура даних**: `Dict[str, float]` - для кожного користувача зберігає час останнього повідомлення
- **Параметри**: `min_interval` (мінімальний інтервал між повідомленнями)
- **Складність**: O(1) для всіх операцій

**Основні методи**:
```python
can_send_message(user_id)                 # Перевірка на основі часу останнього повідомлення
record_message(user_id)                   # Запис з оновленням часу
time_until_next_allowed(user_id)          # Розрахунок часу до наступного дозволеного
get_user_stats()                          # Статистика для всіх користувачів
```

**Алгоритм роботи**:
1. При запиті перевіряється час останнього повідомлення користувача
2. Якщо `current_time - last_message_time >= min_interval` - дозволяється
3. Інакше розраховується час очікування: `min_interval - time_since_last`
4. При успішному запиті оновлюється `last_message_time`

**Переваги**:
- Простота реалізації та розуміння
- Мінімальне використання пам'яті O(1) на користувача
- Гарантований мінімальний інтервал
- Швидкі операції O(1)

**Недоліки**:
- Менш гнучкий контроль
- Не дозволяє "пакетні" запити
- Може бути занадто жорстким для деяких сценаріїв

## Порівняльний аналіз

### Таблиця порівняння

| Характеристика | Sliding Window | Throttling |
|---|---|---|
| **Складність пам'яті** | O(n) де n - запитів у вікні | O(1) на користувача |
| **Складність часу** | O(1) амортизована | O(1) завжди |
| **Гнучкість** | Висока | Середня |
| **Простота реалізації** | Складніша | Простіша |
| **Пакетні запити** | Дозволяє | Не дозволяє |
| **Точність контролю** | Висока | Середня |

### Сценарії використання

**Sliding Window краще для**:
- API rate limiting з точними лімітами (наприклад, "100 запитів на хвилину")
- Сервісів з нерівномірним навантаженням
- Коли потрібна справедливість розподілу ресурсів
- Захисту від DDoS атак

**Throttling краще для**:
- Чат-систем та повідомлень
- Запобігання спаму
- Обмеження частоти дій користувача
- Систем з обмеженими ресурсами пам'яті

## Результати тестування

### Функціональні тести

**Sliding Window (14 тестів)**:
- ✅ Перше повідомлення завжди дозволяється
- ✅ Друге повідомлення блокується в межах вікна  
- ✅ Автоматичне очищення застарілих запитів
- ✅ Видалення користувача при порожньому вікні
- ✅ Правильний розрахунок часу очікування
- ✅ Незалежність користувачів
- ✅ Параметризація (розмір вікна, кількість запитів)

**Throttling (16 тестів)**:
- ✅ Перше повідомлення завжди дозволяється
- ✅ Блокування до закінчення інтервалу
- ✅ Дозвіл після закінчення інтервалу
- ✅ Правильний розрахунок часу очікування
- ✅ Оновлення часових міток
- ✅ Невдалі спроби не впливають на час
- ✅ Незалежність користувачів

### Інтеграційні тести

- ✅ Поведінка в реальному часі
- ✅ Стрес-тест з багатьма користувачами (100)
- ✅ Рапідні спроби від одного користувача

## Технічні деталі реалізації

### Sliding Window - Ключові моменти

1. **Використання `collections.deque`**:
   ```python
   self.user_windows: Dict[str, deque] = {}
   ```
   - Ефективне додавання/видалення з обох кінців
   - O(1) для `append()` та `popleft()`

2. **Автоматичне очищення**:
   ```python
   def _cleanup_window(self, user_id: str, current_time: float):
       cutoff_time = current_time - self.window_size
       while user_window and user_window[0] <= cutoff_time:
           user_window.popleft()
   ```

3. **Управління пам'яттю**:
   ```python
   if not user_window:
       del self.user_windows[user_id]  # Видалення порожніх записів
   ```

### Throttling - Ключові моменти

1. **Простота структури**:
   ```python
   self.last_message_time: Dict[str, float] = {}
   ```

2. **Точне обчислення інтервалу**:
   ```python
   time_since_last = current_time - self.last_message_time[user_id]
   return time_since_last >= self.min_interval
   ```

3. **Захист від негативних значень**:
   ```python
   return max(0.0, self.min_interval - time_since_last)
   ```

## Оптимізації та покращення

### Можливі покращення Sliding Window

1. **Lazy cleanup** - очищення тільки при необхідності
2. **Bucketed timestamps** - групування часових міток
3. **TTL для користувачів** - автоматичне видалення неактивних
4. **Compressed storage** - стиснення даних для економії пам'яті

### Можливі покращення Throttling

1. **Burst allowance** - дозвіл короткочасних "спалахів"
2. **Adaptive intervals** - адаптивні інтервали на основі поведінки
3. **Priority levels** - різні інтервали для різних типів користувачів
4. **Persistence** - збереження стану між перезапусками

### Альтернативні алгоритми

1. **Token Bucket** - накопичення "токенів" для запитів
2. **Leaky Bucket** - рівномірне "витікання" запитів
3. **Fixed Window** - фіксовані часові вікна
4. **Sliding Log** - повний лог усіх запитів

## Практичні рекомендації

### Вибір алгоритму

**Використовуйте Sliding Window коли**:
- Потрібна точність контролю запитів
- Ресурси пам'яті не критичні
- Необхідна справедливість розподілу
- Складність реалізації прийнятна

**Використовуйте Throttling коли**:
- Простота важливіша за гнучкість
- Обмежені ресурси пам'яті
- Потрібен простий захист від спаму
- Швидкість операцій критична

### Параметри налаштування

**Sliding Window**:
- `window_size`: 10-60 секунд для чатів, 1-60 хвилин для API
- `max_requests`: 1-10 для чатів, 100-1000 для API

**Throttling**:
- `min_interval`: 5-30 секунд для чатів, 0.1-1 секунда для API

### Моніторинг та логування

1. **Метрики для відстеження**:
   - Кількість заблокованих запитів
   - Середній час очікування
   - Використання пам'яті
   - Пікове навантаження

2. **Алерти**:
   - Високий відсоток блокувань
   - Занадто довгі часи очікування
   - Аномальна активність користувачів

## Висновки

Обидва алгоритми мають свої переваги та область застосування:

- **Sliding Window** ідеальний для точного контролю API та справедливого розподілу ресурсів
- **Throttling** відмінно підходить для простого захисту від спаму та контролю частоти дій

Вибір залежить від конкретних вимог системи, доступних ресурсів та складності, яку команда готова підтримувати.
